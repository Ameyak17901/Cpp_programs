Teaching Guidelines for
Algorithms and Data Structures Using Java
PG-DAC September 2023
Duration: 72 hours (32 theory hours + 32 lab hours + 8 revision/practice hours)

Objective: To reinforce knowledge of problem solving techniques, data structure concepts and analysis of different algorithms using Java.

Prerequisites: Knowledge of programming in C/C++ with object oriented concepts

Evaluation: 100 Marks
Weightage: CCEE – 40%, Lab exam – 40%, Internals & Mini project – 20%

Text Book:
o Data Abstraction and Problem Solving with Java: Walls and Mirrors by Janet Prichard , Frank M. Carrano / Pearson

References:
•	Problem Solving: Best Strategies to Decision Making, Critical Thinking and Positive Thinking by Thomas Richards / Kindle Edition
•	Data Abstraction and Problem Solving with Java: Walls and Mirrors by Janet Prichard , Frank M. Carrano / Pearson
•	Object-oriented Analysis and Design Using UML - An Introduction to Unified Process and Design Patterns by Mahesh P. Matha / PHI
•	Introduction to Algorithms by Cormen, Leiserson, Rivest and Stein


 

Session 1:
 
(Note: Each Session is of 2 hours)
 
Problem Solving & Computational Thinking Lecture:
●	Define the problem
●	Identify the problem
●	Introduction to Problem Solving
●	Problem solving basics
Lab:
●	Faculty needs to assign different problems, mostly real world problems
●	Students (team-wise, two students in a team) need to analyze as per the techniques learned
●	Based on the above problems students need to select as per the selection criteria learned
●	They need to implement the selected solution and need to do the documentations.
●	Introducing the mini project ideas

Sessions 2 & 3:
Algorithms & Data Structures
Objective: At the end of the session students should know, what is the importance of data structure in problem solving. How stacks, queues, circular queues work. Their real world applications. How to solve problems using these data structures.
 
Lecture:
●	Introductory Concepts
●	Algorithm Constructs
●	Complexity analysis of algorithms (Big O notation )
●	OO design: Abstract Data Types (ADTs)
●	Basic Data Structures
o	Arrays
o	Stacks
o	Queues
o	Circular Queues
Lab:
●	Implement stack through array
●	Complexity analysis of loops and recursive algorithms.
●	Implement queues with inserting element at different location (First, Last)
●	Implement circular queue

Sessions 4 & 5:
Linked List Data Structures
Objective: At the end of the session students should know, what are applications of Linked List, different types of link list. Comparison with arrays as when to use linked list and when to use array.
Lecture:
●	Linked lists
o	Singly linked lists
o	Doubly linked lists
o	Circular linked lists
o	Node-based storage with arrays
Lab:
●	Implement circular queue using linked list
●	Implement stack using linked list

Session 6:
Recursion
Objective: At the end of the session students should know what is recursion, type of recursion, local variable in recursion, stack manipulation during recursion, function complexity
Lecture & Lab:
●	What is recursion?
●	What is the base condition in recursion.
●	Direct and indirect recursion.
●	Memory is allocated to different function calls in recursion.
●	Pro and cons of recursion
●	Function complexity during recursion

Sessions 7 & 8:
Trees & Applications
Objective: At the end of the session students should know what is the use of binary trees, how to create binary search trees. Different tree traversals. What are the applications of binary trees? How to calculate search complexity in binary search trees? What are the limitations of binary search trees? What are different options to overcome the binary search tree limitations.
 
Lecture:
●	Introduction to trees
●	Trees and terminology
●	Tree traversals
●	Binary trees
●	Complete binary trees / Almost complete binary tree (ACBT)
●	Array implementation of ACBT
●	Binary search trees
●	AVL tree
Lab:
●	Write a program to implement a binary search tree and the following operations on it:
o	Create()
o	Tree traversals - Breadth First Search, Depth First Search, Inorder(), Preorder(), Postorder()
o	Delete()

Sessions 9, 10 & 11:
Searching & Sorting Algorithms
Objective: At the end of the session students should know what are the different types of sorting and searching algorithms, why all the sorting algorithms are equally important despite different time/space complexity of the algorithms. How the complexity is calculated for each of them. How to pick a sorting algorithm given the nature of the data to be sorted.
Lecture:
●	Objectives of Searching
o	The Sequential Search
o	Analysis of Sequential Search
o	The Binary Search
●	Analysis of Binary Search
●	Introduction to sorting
o	Selection sort
o	Insertion sort
o	Bubble sort
o	Heapsort
o	Mergesort
o	Quicksort
●	Analysis of sorting algorithms
Lab:
●	Writing program to search an item through sequential search technique.
●	Implement to find an item in a list through binary search
●	Implement sorting algorithm for: insertion sort, Quicksort

Session 12:
Hash Functions and Hash Tables
Objective: At the end of the session students should know what is hashing, what is the importance of hashing, comparative complexity of hashing with other search techniques. Problems (collision) with hashing and what are the different solutions of that.
Lecture:
●	Hashing & Introduction to hash tables
●	Hash Functions
●	Different type of hash functions
 
●	Collision Resolution
●	Linear Probing
●	Quadratic Probing
●	Double Hashing
●	Inserting and Deleting an element from a hash table
Lab:
●	Implement hashing techniques in different programs solved earlier
●	Write a program to implement Hash table
●	Fibonacci recursive algorithm improvement using hash table

Sessions 13 & 14:
Graphs & Applications
Objective: At the end of the session students should know what is graph? Why is graph the most generic data structure? Different types of graphs. Different representation of graph? Graph traversals (Breadth First Traversal, Depth First Traversal). Different applications which can be solved with graphs, real world and programming problems with graphs.
Lecture:
●	Introduction to graph theory
●	Graph Terminology
●	Different types of Graphs
●	Representation of Graphs
o	Adjacency Matrix
o	Adjacency List
o	Graph Traversal Algorithms ( Breadth First Search, Depth First Search)
●	Shortest Path
o	Level Setting : Dijkstra's algorithm
o	Level Correcting: All-pairs shortest path, Floyd-Warshall algorithm
●	Spanning Trees
o	Minimum spanning tree algorithms,
o	Prim's algorithm
o	Kruskal's Algorithm
Lab:
●	Implement a graph using adjacency Matrix and traverse using Depth First Search.
●	Implement a graph and do traversal using stack and queue.

Sessions 15 & 16:
Algorithm Designs
Objective: At the end of the session students should know what are different classes of algorithms. What is the nature of each class of algorithms? How to pick an algorithm for a particular problem. What problems fall under each class of algorithms. What are the worst case, average case and the best case for algorithms?
Lecture:
●	What are the different class of algorithms
●	How to write efficient Algorithm
●	Introduction to algorithm design techniques
●	Algorithm Design techniques
●	Analysis of an Algorithm
o	Asymptotic Analysis
o	Algorithm Analysis
 
●	Analysis of different type of Algorithms
o	Divide and Conquer Algorithm
o	Greedy algorithm
o	Dynamic Programming algorithm
o	Brute force algorithm
o	Backtracking algorithms
o	Branch-and-bound algorithms
o	Stochastic algorithms
●	Complexity
o	Complexity Analysis
o	Space complexity of algorithm
o	Time complexity of algorithm
●	Case study on Algorithm Design techniques
●	Application of Data structures
Lab + Assignment:
●	Study on different Algorithms
●	Compare different Algorithms previously programmed and do the analysis
